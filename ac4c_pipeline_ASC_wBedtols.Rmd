---
title: "Quantification of N4-acetylcytidine at single base resolution"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Description of the code

This code is used to quantify N4-acetylcytidine levels at single base resolution and to indentify sites 
significantly modified in treatment vs control samples.

In short, base calling conducted by JACUSA at pileup mode (doi: 10.1186/s12859-016-1432-8)
is used as input for downstream analysis. Each sample in the array has a corresponding input file generated by 
JACUSA. The user should re-name the files to include the sample name followed by the suffix **_pileup.txt** 
(e.g., "treatment_pileup.txt", "mock_pileup.txt", "KO_pileup.txt" etc.).
The code combines information from the **JACUSA input** files, with information from a **bed file** (BED6 or BED12;
suffix ".bed"), a **fasta file** (suffix ".fasta") and a **fai file** (suffix ".fai"), which represent the genome
and annotations of the relevant organism.
The input files are parsed and analyzed according to parameters defined by the user in a **params.txt** file.
All the aformentioned files (marked in bold) should be present in the working directory.
In addition, the code utilizes bedtools, which has to be installed and available in the user's PATH. https://en.wikipedia.org/wiki/PATH_(variable)

The code outputs a **.Rdata** file, which holds a dataframe of all bases found to be significantly modified in at least 
one of the user defined comparisons made on the array. The level of modification is calculated by deviding the number of 
misincorporated bases for a given position by the total number of reads in that that postion (".*mismstchRate" columns
in the final dataframe).
Three representative plots are also stored in the .Rdata file, depicting a boxplot and heatmap of all significant sites 
in all samples in the array (Note that modification level is shown in %, not as the calculated misincorporation ratio),
as well as a pie chart displaying the frequency of the trinucleotide sequence motif surrounding the modified site (expected to be "CCG").

Information about the user defined parameters file:
The params.txt file holds information on which samples are used as treatment (marked as "1") and which are used as control
(marked as "-1"). samples not used in a specific comparison are marked as "0". 
Note that:
1) the names in the "sampleName" column should be identical to the name given by the user to the JACUSA input files 
(e.g. for a file named "treatment_pileup.txt", write "treatment" in the "sampleName" column).
1) the title of each comparison should be in the form of "**comp_**sampleName1**__**sampleName2" for proper parsing.
where sampleName1 and sampleName2 are identical to the names in the "sampleName" column.


In addition, it specifies the following parameters used to identify significantly modified sites:
1) the minimal number of misincorporations (C to T) requiered to consider a site as modified in the 
treatment samples (useually set to 3). i.e., sites with less than 3 C to T conversions will be considered non-significant.
2) upper threshold of chisq test p value (useually set to 0.05). i.e., sites with p value > 0.05 will be considered non-significant.
3) lower threshold for differance in misincorporation of treatment vs control sample (useually set to 0.02). i.e., sites with
difference < 2% will be considered non-significant.   
4) upper threhold of misincorporation in control samples (useually set to 0.01-0.05). Note that for chemical deacetylation controls
a higher hreshold should be set, as partial deacetylation might result in relatively high levels of misincorporation compared to 
mock treated samples.
5) optional glmer test: if replicates exist, it is possible to complement the default chisq test with and additional glmer test
which is more stringent and more time consuming. This test is done by fitting a generalized linear mixed-effects model (GLMM) to the data. 
Each of these 5 parameters can be defined seperatly for each comparison in the array. For an example see the file **params.xlsx**.


## Demo data
The files "treatment_pileup.txt", "mock_pileup.txt" and "deacetylation_pileup.txt" are to be processed when running the code below.
They represent data from NaCNBH3-treated, mock-treated and deacetylated-NaCNBH3-treated samples, respectively.
The code calculates misincorporation scores (mismatchRate) for each position in each sample and conducts statistical tests (chisq test,
and an optional glm test) to identify positions significantly modified in treated versus control samples.

## General information
The code has been tested using R version 3.6.0. 
No non-standard hardware is needed.

R can be downloaded freely and installed in less than 10 minutes on a "normal" desktop computer.
Running the code from the directory where the input files are found.


## Code
```{r psiScore,  warning=FALSE, message=FALSE}
#!/usr/bin/env Rscript
#############################################################################################
# Dependencies
#############################################################################################
library(reshape2)
library(base)
library(plyr) 
library(stringr)
library(seqinr)
library(dplyr) 
library(lme4) 
library(pheatmap)
library(ggplot2)

#############################################################################################
# functions
#############################################################################################
# reverse complement
revcomp = function(DNAstr) {
  step0 = toupper(DNAstr)
  step1 = chartr("ACGT","TGCA",step0)
  step2 = unlist(strsplit(step1, split=""))
  step3 = rev(step2)
  step4 = paste(step3, collapse="")
  return(step4)
}

# chisq test
multiChi=function(blacks,whites,group,reps) {
  tt=do.call(rbind,lapply(1:length(blacks),function(i) {
    #print(i)
    if(anyNA(c(blacks[i], whites[i])) | all(c(blacks[i], whites[i])==0)){
      df = setNames(data.frame(matrix(ncol = 3, nrow = 0)), c("group", "rep", "iswhite"))
    } else{
      df = data.frame(group=group[i],rep=reps[i],iswhite=rep(c(0,1),c(blacks[i],whites[i])))}
  }))
  tt$group_rep=paste(tt$group,tt$rep,sep="_")
  if(length(unique(tt$group_rep))>1){
    m1 = tryCatch({glmer(iswhite ~ group + (1|group_rep), data=tt, family="binomial")}, error=function(e){return(NA)})
    if(is.na(m1)){glmpvalrep=NA}else{
      glmpvalrep=coef(summary(m1))[,'Pr(>|z|)'][2]
    }} else{
      glmpvalrep=NA
    }
}

# add bases flanking a known position
addSlop = function(myBed, genomeFai, genomeFasta, N){ 
  outFile1 = paste0(inDir, "_dfM1_slop", as.character(N), ".txt")
  outFile2 = paste0(inDir, "_dfM1_slop", as.character(N), "_seq.txt")
  system(paste0("bedtools slop -i ", myBed, " -g ", genomeFai, " -b ", as.character(N), " -s > ", outFile1), intern=TRUE)
  system(paste0("bedtools getfasta -fo ", outFile2, " -tab -s -fi ", genomeFasta, " -bed ", outFile1), intern=TRUE)
  seqFile = read.table(outFile2, sep="\t")
  return(seqFile)
}

#############################################################################################
# uploads
#############################################################################################
#args = commandArgs(trailingOnly=TRUE)

inDir=getwd()

inFile = list.files(inDir, pattern="params.txt",full.names=TRUE)
bedFile = list.files(inDir, pattern=".bed",full.names=TRUE)
genomeFai = list.files(inDir, pattern=".fai",full.names=TRUE)
genomeFasta = list.files(inDir, pattern=".fasta$",full.names=TRUE)

files = list.files(inDir, pattern="pileup.txt",full.names=TRUE)

## parse parameters file ##
in1 = read.table(inFile, fill=TRUE, stringsAsFactors=FALSE)

# define start position of each chunk of info
i1 = grep("sampleInfo", in1$V1)
i2 = grep("parameters", in1$V1)

# create variable holding info on all comparisons
compFile = in1[(i1+2):(i2-1),]
names(compFile) = c("sample", "sampleName", (in1[(i1+1),3:(length(in1))]))
compCol = gsub("comp_", "", grep("comp", names(compFile), value=TRUE))
names(compFile) = gsub("comp_","", names(compFile))

combi2 = lapply(1:length(compCol), function(x){
  treat = grep("^1", compFile[,compCol[x]])
  cont = grep("-1", compFile[,compCol[x]])
  list(as.character(compFile[treat,"sampleName"]), as.character(compFile[cont,"sampleName"]))
})

combi1 = lapply(1:length(combi2), function(x){
  #print(x)
  data.frame(treat=I(list(combi2[x][[1]][[1]])), cont=I(list(combi2[x][[1]][[2]])))
})


# df holding cuttoff parametrs for each comparison
params = as.data.frame(t(in1[(i2+1):nrow(in1),1:(length(in1)-1)]),stringsAsFactors=FALSE)
names(params) = as.character(params[1,])
params = params[2:nrow(params),]
params$sampleName = names(compFile)[3:length(compFile)]
params$minDiff = as.numeric(as.character(params$minDiff))
params$minWrong = as.numeric(as.character(params$minWrong))
params$maxContMis = as.numeric(as.character(params$maxContMis))

minWrong = min(params$minWrong)


#############################################################################################
# parsing data and calculating ac4c levels
#############################################################################################
fList = lapply(1:nrow(compFile), function(x){
    df0 = read.delim(compFile[x,1], comment.char = '#', header=F)
  names(df0) = c("chr", "start", "end", "method", "total", "strand", "counts", "comment", "base")
  

  # filter out positions which are not in the annotation (bed file)
  #####################################################################
  tmp1 = paste0(inDir,"tmp1.txt")
  write.table(df0[,c(1:6)], tmp1, sep="\t", row.names = F, quote = F, col.names = F)
  tmp2 = paste0(inDir,"tmp2.txt")
  comm = paste0("bedtools intersect -s -a ", tmp1, " -b ", bedFile, " -split -wb > ", tmp2)
  system(command = comm, intern=TRUE)
  tmp3 = read.table(tmp2, sep="\t")
  tmp3$id  = paste0(tmp3$V1, ":", tmp3$V3, "_", tmp3$V6)
  
  df0$id =  paste0(df0$chr, ":", df0$end, "_", df0$strand)
  
  df = subset(df0, id %in% tmp3$id)
  
  # parsing
  #####################################################################
  splitBases = strsplit(as.character(df$counts), split=",")
  b = data.frame(matrix(unlist(splitBases), nrow=nrow(df), byrow=TRUE))
  names(b) = c("A", "C", "G","T")
  b$A =as.numeric(as.character(b$A))
  b$C =as.numeric(as.character(b$C))
  b$G =as.numeric(as.character(b$G))
  b$T =as.numeric(as.character(b$T))
  
  df = cbind(df,b)
  
  # Define true base
  #####################################################################
  r1 = df[df$strand=="+",]
  r1$trueBase = r1$base
  r2 = df[df$strand=="-",]
  r2$trueBase = apply(as.data.frame(r2[,"base"]),1,revcomp)
  
  df = rbind(r1,r2)
  df = df[df$trueBase!="N",]
  
  # Define mismatch rate. create correct, wrong and mismatch columns
  #####################################################################
  df$correct = ifelse(df$trueBase=="A", df$A, ifelse(df$trueBase=="C", df$C, ifelse(df$trueBase=="G", df$G,  df$T)))
  df$wrong = df$total - df$correct
  df$mismatchRate = 1-(df$correct/df$total)
  
  # Define conversion type
  #####################################################################
  s1 = subset(df, mismatchRate==0 )
  s1$snp = as.factor(rep(NA, nrow(s1)))
  s2 = subset(df, mismatchRate!=0 )
  
  SNP = lapply(1:nrow(s2), function(x){
    a = as.character(s2[x,"trueBase"])
    cols = setdiff(c("A", "C", "G", "T"), a) # 
    b = cols[which(s2[x,cols]==max(s2[x,cols]))]
    snp = paste0(a,paste(b, collapse=""))
  })
  snp = data.frame(snp=matrix(unlist(SNP), nrow=nrow(s2), byrow=TRUE))
  s2 = cbind(s2,snp)
  
  df = rbind(s1, s2)
  df = df[,c(1,2,3,10,6,15,7,5,16,17,18,19)]
  
  #sampleName = gsub("_pileup.txt","", files[x])
  sampleName = compFile[x,2]

  #sampleName = gsub(".*\\/|_pileup.txt","", files[x])
  names(df)[7:12] = paste0(sampleName,"_", names(df)[7:12])
  
  df
})
######
# merge data frames of all samples
#####################################################################
dfM = Reduce(function(x, y) merge(x, y, all=TRUE), fList)

# define columns of interest
#####################################################################
rateCol = grep("Rate", names(dfM), value=TRUE)

# define rate columns used as treatment samples
alltreat = paste0(as.character(unique(unlist(lapply(1:length(combi1), function(x){
  combi1[[x]]$treat
})))), "_mismatchRate")

# define rate columns used as control samples
allcont = paste0(as.character(unique(unlist(lapply(1:length(combi1), function(x){
  combi1[[x]]$cont
})))), "_mismatchRate")

# define wring columns used as treatment samples
wCol = paste0(as.character(unique(unlist(lapply(1:length(combi1), function(x){
  combi1[[x]]$treat
})))), "_wrong")

# create filters. keep only rows that receive TRUE in the filters below 
filter1 = apply(dfM[,rateCol], 1, function(x) length(unique(x[!is.na(x)])) != 1) # not all mismatch columns are equal
if(length(alltreat)>1){
  filter2 = apply(!is.na(dfM[,alltreat]), 1, any)}else{
    filter2 = !is.na(dfM[,alltreat])} # at least one treatment mismatch column !=NA
if(length(allcont)>1){
  filter3 = apply(!is.na(dfM[,allcont]), 1, any)}else{
    filter3 = !is.na(dfM[,allcont])} # at least one control mismatch column !=NA
if(length(wCol)>1){
  filter4 = apply(dfM[,wCol]>=minWrong, 1, any, na.rm=TRUE)}else{
    filter4 = dfM[,wCol]>=minWrong} # at least one treatment column has a minimal number of wrong bases (>= minWrong). not limited to C->T, this will come later
keep1 = apply(as.data.frame(cbind(filter1, filter2, filter3, filter4))==TRUE,1,all)

# filter original df to keep only sites with a potential interest. no statistics involved.
dfM2 = dfM[keep1,]

# calculate difference between pair-wise comparisons
#####################################################################
Diff = lapply(1:length(combi1), function(x){
  colT = grep(paste(paste0(combi1[[x]]$treat[[1]],".*Rate"), collapse="|"), names(dfM2), value=TRUE)
  colC = grep(paste(paste0(combi1[[x]]$cont[[1]],".*Rate"), collapse="|"), names(dfM2), value=TRUE)
  d = lapply(1:nrow(dfM2), function(y){
    median(as.numeric(dfM2[y,colT]), na.rm=TRUE)-median(as.numeric(dfM2[y,colC]), na.rm=TRUE)
  })
})

diff = data.frame((matrix(unlist(Diff), nrow=nrow(dfM2), byrow=FALSE)))
names(diff) = paste0("diff_", compCol)

dfM2 = cbind(dfM2, diff)


# conduct chisq test and register its p value
#####################################################################
chisq = do.call(cbind,lapply(1:length(combi1), function(y){
  test = lapply(1:nrow(dfM2), function(x){
    if(all(is.na(dfM2[x,grep(paste(paste0(combi1[[y]]$treat[[1]],".*wrong"), collapse="|"), names(dfM2), value=TRUE)]))|
       all(is.na(dfM2[x,grep(paste(paste0(combi1[[y]]$cont[[1]],".*wrong"), collapse="|"), names(dfM2), value=TRUE)]))){
      test = NA
    } else{
      cnMut = sum(dfM2[x,grep(paste(paste0(combi1[[y]]$treat[[1]],".*wrong"), collapse="|"), names(dfM2), value=TRUE)], na.rm=TRUE) 
      cnWT = sum(dfM2[x,grep(paste(paste0(combi1[[y]]$treat[[1]],".*correct"), collapse="|"), names(dfM2), value=TRUE)] , na.rm=TRUE) 
      hclMut = sum(dfM2[x,grep(paste(paste0(combi1[[y]]$cont[[1]],".*wrong"), collapse="|"), names(dfM2), value=TRUE)] , na.rm=TRUE) 
      hclWT = sum(dfM2[x,grep(paste(paste0(combi1[[y]]$cont[[1]],".*correct"), collapse="|"), names(dfM2), value=TRUE)] , na.rm=TRUE) 
      m = matrix(c(cnMut,cnWT,hclMut,hclWT),byrow=TRUE, 2, 2)
      tryCatch({chisq.test(m)$p.value}, error=function(e) {return(NA)})
    }
  })
  chisq1 = as.data.frame(matrix(unlist(test)))
}))

names(chisq) = paste0(compCol, "_chisq")

dfM2 = cbind(dfM2, chisq)

#write.table(dfM2, file=file.path(inDir,"dfM2.txt"), sep="\t")
##$$##
# identify significant rows according to filter parameters
#####################################################################
sigCols = as.data.frame(do.call(cbind, lapply(1:length(combi1), function(x){
  p = as.numeric(as.character(params[x,"pval"]))
  minW = as.numeric(as.character(params[x,"minWrong"]))
  minDiff = as.numeric(as.character(params[x,"minDiff"]))
  maxContMis = as.numeric(as.character(params[x,"maxContMis"]))
  f1 = as.data.frame(do.call(rbind, lapply(1:nrow(dfM2), function(y){
    p_val = dfM2[y,paste0(params[x,"sampleName"], "_chisq")]
    diff_val = dfM2[y,grep(paste(paste0("diff_", params[x,"sampleName"]), collapse="|"), names(dfM2))]
    if(is.na(p_val) | p_val > p | diff_val < minDiff){
      data.frame(isSig = 0)}else{
        a = dfM2[y,grep(paste(paste0(combi1[[x]]$cont[[1]], ".*Rate"), collapse="|"), names(dfM2))]<maxContMis # limit maximal mismatch rate of control samples
        a1 = sum(a==TRUE, na.rm=TRUE)>=ceiling(length(a)/2)
        b =  dfM2[y,grep(paste(paste0(combi1[[x]]$treat[[1]], "_snp"), collapse="|"), names(dfM2))]=="CT" # demand a dominant C to T conversion
        b1 = sum(b==TRUE, na.rm=TRUE)>=ceiling(length(b)/2)
        d = dfM2[y,grep(paste(paste0(combi1[[x]]$treat[[1]], "_T$"), collapse="|"), names(dfM2))]>minW # limit minimal C to T incidents
        d1 = sum(d==TRUE, na.rm=TRUE)>=ceiling(length(d)/2)
        if(!a1){data.frame(isSig = 0)}else{
          sig = ifelse(b1&d1, 1,0)
          data.frame(isSig = sig)
        }
      }
  })))
  names(f1) = paste0(params[x,"sampleName"], "_", names(f1))
  f1
})))


dfM2 = cbind(dfM2, sigCols)
dfM2$nSig = apply(dfM2[,grep("isSig", names(dfM2))],1,sum,na.rm=T)
 
# filter out site with no significant comparisons 
#####################################################################  
dfM3 = subset(dfM2, nSig>0)  # make glm only on sites which were found significant so far (without C to T parameter)

# Conduct a glmer fitting and testing of significance
#####################################################################
glmColsN = gsub(".*__", "", params[grep("TRUE", params$glm),"sampleName"])
doGLM = length(glmColsN)>0

if(doGLM){
  Ns = grep(paste(glmColsN, collapse="|"),params$sampleName)
  glmCalc = lapply(1:length(Ns), function(x){
    if(Ns[x]){
      colT1 = unique(as.character(combi1[[Ns[x]]]$treat[[1]]))
      colC1 = unique(as.character(combi1[[Ns[x]]]$cont[[1]]))
      cols = grep(paste0("wrong|correct"),grep(paste(paste0(colT1,"|", colC1),collapse="|"), names(dfM3), value=TRUE),value=TRUE)
      t = dfM3[,cols]
      g = lapply(1:nrow(t), function(y){
        t1 = data.frame(wt = melt(t[y,grep(paste0(colT1, ".*correct"), names(t), value=TRUE)]), 
                        mut = melt(t[y,grep(paste0(colT1, ".*wrong"), names(t), value=TRUE)]))
        t1$group = rep("group1", nrow(t1))
        t1$rep = 1:nrow(t1)
        t3 = t1[,grep("value|group|rep", names(t1))]
        names(t3) = c("wt", "mut", "group","rep")
        t2 = data.frame(wt = melt(t[y,grep(paste(paste0(colC1, ".*correct"), collapse="|"), names(t), value=TRUE)]), 
                        mut = melt(t[y,grep(paste(paste0(colC1, ".*wrong"), collapse="|"), names(t), value=TRUE)]))
        t2$group = rep("group2", nrow(t2))
        t2$rep = 1:nrow(t2)
        t4 = t2[,grep("value|group|rep", names(t2))]
        names(t4) = c("wt", "mut", "group","rep")
        t5 = rbind(t3,t4)
        if(max(t5[,c("wt","mut")], na.rm=TRUE)<1000){
          glm1 = multiChi(t5$mut+1,t5$wt+1,t5$group,t5$rep)
        } else{
          fold = max(t5[,c("wt","mut")], na.rm=TRUE)/1000
          t6 = t5
          t6[,c("wt","mut")] = round((t6[,c("wt","mut")]/fold),0)
          glm1 = multiChi(t6$mut+1,t6$wt+1,t6$group,t6$rep)
        } 
      })
      g2 = as.data.frame(matrix(unlist(g)))
    }
  })
  GLM = do.call(cbind,glmCalc)
  names(GLM) = paste0(glmColsN, "_glmPval")
  
  dfM3 = cbind(dfM3, GLM)
}

# add surrounding bases
#####################################################################
dfM3_bed = dfM3[,c("chr", "start", "end", "id", "trueBase", "strand")]
mybed = paste0(inDir,"dfM3_bed.bed")
write.table(dfM3_bed, mybed, sep="\t", row.names=FALSE, quote=FALSE, col.names = FALSE)
slop=10

seq = addSlop(mybed, genomeFai, genomeFasta, slop)

dfM3$surrSeq = toupper(seq$V2)
dfM3$motif = factor(substr(dfM3$surrSeq,slop,slop+2))

significantSites = dfM3

# prepare dataframes for plots
#####################################################################
tbl = melt(dfM3[,grep("id|Rate|true", names(dfM3))])
tbl1 = as.data.frame(table(dfM3$motif))
names(tbl1) = c("Motif", "Frequency")
tbl2 = dfM3[,grep("Rate", names(dfM3))]
tbl2 = tbl2*100
row.names(tbl2) = dfM3$id

# plots
#####################################################################
plotHeatmap = pheatmap(tbl2, border_color = NA, silent = T)

plotSigSites = ggplot(tbl, aes(x=variable, y=value*100))+geom_boxplot()+theme_classic()+ylab("Misincorporation (%)")+xlab("")

plotMotifPie = ggplot(tbl1, aes(x="",y=Frequency, fill=Motif))+
  geom_bar(width=1,stat="identity")+
  coord_polar("y", start=0)+
  theme_classic()

save(significantSites, plotHeatmap, plotSigSites, plotMotifPie, file=file.path(inDir,"ac4c_data_plots.Rdata"))
write.table(significantSites, sep="\t", quote = F, row.names = F, file=file.path(inDir,"ac4c_significantSites.txt"))

```

## Including Plots

Comparison of ac4c levels (misincorporation levels) in a NaCNBH3-treated sample and two controls: 
chemical deacetylation and mock. As expected misincorporation rate in treatment > deacetylation > mock.
Only sites found significant in at least one comparison are shown.

```{r plot1, echo=FALSE}
plot(plotSigSites)
```
<br><br><br>
Pie chart of all identified trinucleotide motifs around the significant ac4c sites.
In this example all sites were found within a CCG motif.

```{r plot2, echo=FALSE}
plot(plotMotifPie)
```
<br><br><br>
Heatmap of ac4c levels (misincorporation levels) in a NaCNBH3-treated sample and two controls: 
chemical deacetylation and mock. Only sites found significant in at least one comparison are shown.

```{r plot3, echo=FALSE}
plot(pheatmap(tbl2, border_color = NA))

```

## References
The code is based on the ac4c-seq method for whole transcriptome quantificatin of ac4c at single base resolution, first published in Sas-Chen, A., Thomas, J.M., Matzov, D. et al. Dynamic RNA acetylation revealed by quantitative cross-evolutionary mapping. Nature 583, 638–643 (2020). https://doi.org/10.1038/s41586-020-2418-2

## Session information

Technical information of the system were this code was run.

```{r}
sessionInfo()
```

